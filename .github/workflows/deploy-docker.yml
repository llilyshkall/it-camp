name: Deploy to Server (Docker)

on:
  push:
    branches: [ master, develop ]
  pull_request:
    branches: [ master ]
  workflow_dispatch: # Позволяет запускать вручную

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/evaluation

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.22.5'
          cache: true

      - name: Run tests
        working-directory: ./services/evaluation
        run: |
          go test -v ./...
          go vet ./...
          go fmt ./...

      - name: Build binary
        working-directory: ./services/evaluation
        run: |
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o evaluation ./cmd/evaluation

  build-and-push:
    name: Build and Push Docker Image
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./services/evaluation
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Server
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    environment: production
    permissions:
      contents: read
      issues: write
    steps:
      - name: Deploy to server via SSH
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_PORT || 22 }}
          script: |
            # Создаем директорию для приложения в домашней папке пользователя
            mkdir -p ~/evaluation
            
            # Устанавливаем golang-migrate на сервере
            echo "Installing golang-migrate..."
            if ! command -v migrate >/dev/null 2>&1; then
              curl -L https://github.com/golang-migrate/migrate/releases/latest/download/migrate.linux-amd64.tar.gz | tar xvz
              mv migrate ~/migrate
              export PATH=$HOME:$PATH
              echo "golang-migrate installed successfully"
            else
              echo "golang-migrate already installed"
            fi
            
            # Проверяем, что golang-migrate доступен
            if [ ! -f ~/migrate ]; then
              echo "❌ golang-migrate installation failed"
              exit 1
            fi
            echo "✅ golang-migrate is ready: $(~/migrate -version)"
            
            # Копируем папку migrations на сервер
            echo "Copying migration files..."
            mkdir -p ~/evaluation/migrations
            cp -r ../../services/evaluation/db/migration/* ~/evaluation/migrations/
            
            # Проверяем, что файлы миграций скопировались
            echo "Verifying migration files..."
            if [ ! -f ~/evaluation/migrations/000001_create_tables.up.sql ]; then
              echo "❌ Migration files not copied correctly"
              exit 1
            fi
            echo "✅ Migration files copied successfully"
            
            # Проверяем, что пользователь в группе docker
            if ! groups | grep -q docker; then
              echo "User not in docker group. Adding to docker group..."
              sudo usermod -aG docker $USER
              echo "Please log out and log back in, or run: newgrp docker"
            fi
            
            # Авторизация в GitHub Container Registry
            echo "Authenticating with GitHub Container Registry..."
            if ! echo ${{ secrets.PACKAGES_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin; then
              echo "❌ Failed to authenticate with GitHub Container Registry"
              exit 1
            fi
            
            # Останавливаем старые контейнеры (игнорируем ошибки для первого запуска)
            echo "Stopping old containers..."
            docker-compose down 2>/dev/null || echo "No existing docker-compose to stop"
            docker stop evaluation postgres 2>/dev/null || echo "No existing containers to stop"
            docker rm evaluation postgres 2>/dev/null || echo "No existing containers to remove"
            
            # Создаем docker-compose.yaml для продакшна
            echo "Creating production docker-compose.yaml..."
            cat > ~/evaluation/docker-compose.yaml << 'EOF'
            services:
              evaluation:
                image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:master
                ports:
                  - "8081:8080"
                environment:
                  - PORT=8080
                  - ENVIRONMENT=production
                  - DB_HOST=postgres
                  - DB_PORT=5432
                  - DB_NAME=evaluation_db
                  - DB_USER=evaluation_user
                  - DB_PASSWORD=${{ secrets.DB_PASSWORD }}
                  - DB_SSLMODE=disable
                  - DB_CONNECT_TIMEOUT=10s
                  - DB_MAX_OPEN_CONNS=25
                  - DB_MAX_IDLE_CONNS=5
                  - DB_CONN_MAX_LIFETIME=5m
                  - MINIO_ENDPOINT=minio:9000
                  - MINIO_ACCESS_KEY=${{ secrets.MINIO_ACCESS_KEY }}
                  - MINIO_SECRET_KEY=${{ secrets.MINIO_SECRET_KEY }}
                  - MINIO_BUCKET_NAME=evaluation-files
                  - MINIO_USE_SSL=false
                  - MINIO_REGION=us-east-1
                  - READ_TIMEOUT=10s
                  - WRITE_TIMEOUT=10s
                  - IDLE_TIMEOUT=60s
                  - SHUTDOWN_TIMEOUT=30s
                  - LOG_LEVEL=info
                depends_on:
                  - postgres
                  - minio
                restart: unless-stopped
                networks:
                  - evaluation-network
            
              postgres:
                image: postgres:15-alpine
                environment:
                  - POSTGRES_DB=evaluation_db
                  - POSTGRES_USER=evaluation_user
                  - POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD }}
                ports:
                  - "5432:5432"
                volumes:
                  - postgres_data:/var/lib/postgresql/data
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U evaluation_user -d evaluation_db"]
                  interval: 10s
                  timeout: 5s
                  retries: 5
                restart: unless-stopped
                networks:
                  - evaluation-network
                  
              minio:
                image: minio/minio:latest
                ports:
                  - "9000:9000"
                  - "9001:9001"
                environment:
                  - MINIO_ROOT_USER=${{ secrets.MINIO_ACCESS_KEY }}
                  - MINIO_ROOT_PASSWORD=${{ secrets.MINIO_SECRET_KEY }}
                command: server /data --console-address ":9001"
                volumes:
                  - minio_data:/data
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
                  interval: 30s
                  timeout: 20s
                  retries: 3
                restart: unless-stopped
                networks:
                  - evaluation-network
            
            networks:
              evaluation-network:
                driver: bridge
            
            volumes:
              postgres_data:
              minio_data:
            EOF
            
            # Запускаем PostgreSQL и MinIO сначала
            echo "Starting PostgreSQL and MinIO services..."
            cd ~/evaluation
            if ! docker-compose up -d postgres minio; then
              echo "❌ Failed to start PostgreSQL or MinIO"
              exit 1
            fi
            
            # Ждем готовности PostgreSQL и MinIO
            echo "Waiting for PostgreSQL and MinIO to be ready..."
            sleep 30
            
            # Применяем миграции через golang-migrate
            echo "Applying database migrations..."
            if ! ~/migrate -path ~/evaluation/migrations -database "postgres://evaluation_user:${{ secrets.DB_PASSWORD }}@localhost:5432/evaluation_db?sslmode=disable" up; then
              echo "❌ Failed to apply migrations"
              exit 1
            fi
            echo "✅ Migrations applied successfully"
            
            # Запускаем evaluation сервис
            echo "Starting evaluation service..."
            if ! docker-compose up -d evaluation; then
              echo "❌ Failed to start evaluation service"
              exit 1
            fi
            
            # Ждем готовности evaluation сервиса
            echo "Waiting for evaluation service to be ready..."
            sleep 15
            
            # Проверяем статус миграций
            echo "Checking migration status..."
            if ! ~/migrate -path ~/evaluation/migrations -database "postgres://evaluation_user:${{ secrets.DB_PASSWORD }}@localhost:5432/evaluation_db?sslmode=disable" version; then
              echo "❌ Failed to check migration status"
              exit 1
            fi
            
            # Проверяем статус сервисов
            echo "Services status:"
            if ! docker-compose ps; then
              echo "❌ Services are not running"
              exit 1
            fi
            
            # Проверяем health
            echo "Health check:"
            if ! curl -f http://localhost:8081/health; then
              echo "❌ Health check failed"
              echo "Checking evaluation service logs:"
              docker-compose logs evaluation --tail=20
              exit 1
            fi
            
            echo "✅ Health check passed"
            echo "✅ Deployment completed successfully!"
            
            # Финальная проверка
            echo "Final verification:"
            echo "- PostgreSQL: $(docker-compose ps postgres | grep -c 'Up')/1 containers running"
            echo "- Evaluation: $(docker-compose ps evaluation | grep -c 'Up')/1 containers running"
            echo "- Migration version: $(~/migrate -path ~/evaluation/migrations -database 'postgres://evaluation_user:${{ secrets.DB_PASSWORD }}@localhost:5432/evaluation_db?sslmode=disable' version)"

      - name: Health Check
        run: |
          echo "Waiting for service to be ready..."
          sleep 30
          
          # Проверяем доступность сервиса
          if curl -f "http://${{ secrets.SERVER_HOST }}:8081/health"; then
            echo "✅ Service is healthy and accessible!"
          else
            echo "❌ Service health check failed"
            exit 1
          fi
