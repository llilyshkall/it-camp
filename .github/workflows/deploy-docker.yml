name: Deploy to Server (Docker)

on:
  push:
    branches: [ master, develop ]
  pull_request:
    branches: [ master ]
  workflow_dispatch: # Позволяет запускать вручную

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/evaluation

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.22.5'
          cache: true

      - name: Run tests
        working-directory: ./services/evaluation
        run: |
          go test -v ./...
          go vet ./...
          go fmt ./...

      - name: Build binary
        working-directory: ./services/evaluation
        run: |
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o evaluation ./cmd/evaluation

  build-and-push:
    name: Build and Push Docker Image
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./services/evaluation
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to Server
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    environment: production
    permissions:
      contents: read
      issues: write
    steps:
      - name: Deploy to server via SSH
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_PORT || 22 }}
          script: |
            # Создаем директорию для приложения в домашней папке пользователя
            mkdir -p ~/evaluation
            
            # Устанавливаем golang-migrate на сервере
            echo "Installing golang-migrate..."
            if ! command -v migrate >/dev/null 2>&1; then
              curl -L https://github.com/golang-migrate/migrate/releases/latest/download/migrate.linux-amd64.tar.gz | tar xvz
              mv migrate ~/migrate
              export PATH=$HOME:$PATH
              echo "golang-migrate installed successfully"
            else
              echo "golang-migrate already installed"
            fi
            
            # Проверяем, что golang-migrate доступен
            if [ ! -f ~/migrate ]; then
              echo "❌ golang-migrate installation failed"
              exit 1
            fi
            echo "✅ golang-migrate is ready: $(~/migrate -version)"
            
            # Создаем файлы миграций на сервере
            echo "Creating migration files..."
            mkdir -p ~/evaluation/migrations
            cat > ~/evaluation/migrations/000001_create_tables.up.sql << 'MIGRATION_EOF'
            BEGIN;
            
            CREATE TABLE IF NOT EXISTS projects (
                id SERIAL PRIMARY KEY,
                name VARCHAR(255) NOT NULL,
                created_at TIMESTAMP DEFAULT NOW(),
                in_progress BOOLEAN DEFAULT FALSE NOT NULL
            );
            
            CREATE TABLE IF NOT EXISTS project_files (
                id SERIAL PRIMARY KEY,
                project_id INTEGER NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
                filename VARCHAR(255) NOT NULL,
                original_name VARCHAR(255) NOT NULL,
                file_path VARCHAR(500) NOT NULL,
                file_size BIGINT NOT NULL,
                mime_type VARCHAR(100),
                uploaded_at TIMESTAMP DEFAULT NOW()
            );
            
            CREATE TABLE IF NOT EXISTS remarks (
                id SERIAL PRIMARY KEY,
                project_id INTEGER NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
                direction VARCHAR(255) NOT NULL,
                section VARCHAR(255) NOT NULL,
                subsection VARCHAR(255) NOT NULL,
                content TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT NOW()
            );
            
            COMMIT;
            MIGRATION_EOF
            
            # Проверяем, что пользователь в группе docker
            if ! groups | grep -q docker; then
              echo "User not in docker group. Adding to docker group..."
              sudo usermod -aG docker $USER
              echo "Please log out and log back in, or run: newgrp docker"
            fi
            
            # Авторизация в GitHub Container Registry
            echo "Authenticating with GitHub Container Registry..."
            if ! echo ${{ secrets.PACKAGES_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin; then
              echo "❌ Failed to authenticate with GitHub Container Registry"
              exit 1
            fi
            
            # Останавливаем старые контейнеры (игнорируем ошибки для первого запуска)
            echo "Stopping old containers..."
            docker-compose down 2>/dev/null || echo "No existing docker-compose to stop"
            docker stop evaluation postgres 2>/dev/null || echo "No existing containers to stop"
            docker rm evaluation postgres 2>/dev/null || echo "No existing containers to remove"
            
            # Создаем docker-compose.yaml для продакшна
            echo "Creating production docker-compose.yaml..."
            cat > ~/evaluation/docker-compose.yaml << 'EOF'
            services:
              evaluation:
                image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:master
                ports:
                  - "8081:8080"
                environment:
                  - PORT=8080
                  - ENVIRONMENT=production
                  - DB_HOST=postgres
                  - DB_PORT=5432
                  - DB_NAME=evaluation_db
                  - DB_USER=evaluation_user
                  - DB_PASSWORD=${{ secrets.DB_PASSWORD }}
                depends_on:
                  - postgres
                restart: unless-stopped
                networks:
                  - evaluation-network
            
              postgres:
                image: postgres:15-alpine
                environment:
                  - POSTGRES_DB=evaluation_db
                  - POSTGRES_USER=evaluation_user
                  - POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD }}
                ports:
                  - "5432:5432"
                volumes:
                  - postgres_data:/var/lib/postgresql/data
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U evaluation_user -d evaluation_db"]
                  interval: 10s
                  timeout: 5s
                  retries: 5
                restart: unless-stopped
                networks:
                  - evaluation-network
            
            networks:
              evaluation-network:
                driver: bridge
            
            volumes:
              postgres_data:
            EOF
            
            # Запускаем только PostgreSQL сначала
            echo "Starting PostgreSQL service..."
            cd ~/evaluation
            if ! docker-compose up -d postgres; then
              echo "❌ Failed to start PostgreSQL"
              exit 1
            fi
            
            # Ждем готовности PostgreSQL
            echo "Waiting for PostgreSQL to be ready..."
            sleep 20
            
            # Применяем миграции через golang-migrate
            echo "Applying database migrations..."
            if ! ~/migrate -path ~/evaluation/migrations -database "postgres://evaluation_user:${{ secrets.DB_PASSWORD }}@localhost:5432/evaluation_db?sslmode=disable" up; then
              echo "❌ Failed to apply migrations"
              exit 1
            fi
            echo "✅ Migrations applied successfully"
            
            # Запускаем evaluation сервис
            echo "Starting evaluation service..."
            if ! docker-compose up -d evaluation; then
              echo "❌ Failed to start evaluation service"
              exit 1
            fi
            
            # Ждем готовности evaluation сервиса
            echo "Waiting for evaluation service to be ready..."
            sleep 15
            
            # Проверяем статус миграций
            echo "Checking migration status..."
            if ! ~/migrate -path ~/evaluation/migrations -database "postgres://evaluation_user:${{ secrets.DB_PASSWORD }}@localhost:5432/evaluation_db?sslmode=disable" version; then
              echo "❌ Failed to check migration status"
              exit 1
            fi
            
            # Проверяем статус сервисов
            echo "Services status:"
            if ! docker-compose ps; then
              echo "❌ Services are not running"
              exit 1
            fi
            
            # Проверяем health
            echo "Health check:"
            if ! curl -f http://localhost:8081/health; then
              echo "❌ Health check failed"
              echo "Checking evaluation service logs:"
              docker-compose logs evaluation --tail=20
              exit 1
            fi
            
            echo "✅ Health check passed"
            echo "✅ Deployment completed successfully!"
            
            # Финальная проверка
            echo "Final verification:"
            echo "- PostgreSQL: $(docker-compose ps postgres | grep -c 'Up')/1 containers running"
            echo "- Evaluation: $(docker-compose ps evaluation | grep -c 'Up')/1 containers running"
            echo "- Migration version: $(~/migrate -path ~/evaluation/migrations -database 'postgres://evaluation_user:${{ secrets.DB_PASSWORD }}@localhost:5432/evaluation_db?sslmode=disable' version)"

      - name: Health Check
        run: |
          echo "Waiting for service to be ready..."
          sleep 30
          
          # Проверяем доступность сервиса
          if curl -f "http://${{ secrets.SERVER_HOST }}:8081/health"; then
            echo "✅ Service is healthy and accessible!"
          else
            echo "❌ Service health check failed"
            exit 1
          fi
